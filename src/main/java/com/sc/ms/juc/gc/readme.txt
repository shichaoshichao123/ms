                                GC相关知识复盘

 1：阅读GC日志
   GC：
   [GC (Allocation Failure) [PSYoungGen（GC类型）: 1910K（GC前占用的内存）->496K（GC后占用的内存）(2560K（总共占用的内存）)] 1910K（GC前JVM堆内存占用）->576K（GC后JVM堆内存占用）(9728K（JVM堆内存总占用空间）), 0.0016814（GC耗费的时间） secs] [Times: user=0.00 sys=0.00, real=0.00 secs]

   FullGC：
   [Full GC (Allocation Failure) [PSYoungGen: 496K->0K(2560K)] [ParOldGen: 92K->522K(7168K)] 588K->522K(9728K), [Metaspace: 3298K->3298K(1056768K)], 0.0050083 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]

2：OOM异常全解析：
    要注意的是StackOverflowError和OutOfMemoryError都是错误而不是异常，只是平常口语可能叫异常！

    1：java.lang.StackOverflowError:java线程栈溢出
        方法调用层次深导致方法栈被撑爆了，比较常见的是递归过深导致的。

    2：java.lang.OutOfMemoryError:Java heap space
        对象过多堆内存被占满导致的异常

    3：java.lang.OutOfMemoryError:GC overhead limit exceeded
        在GC执行时间过长也就是98%的时间都用于处理垃圾回收的情况下，不一会内存又被填满又开始GC的恶性循环，这是就会抛出这个异常。

    4：java.lang.OutOfMemoryError:Direct buffer memory
        直接内存也叫直接内存（MetaSpace所属的空间就是直接内存，也就是本地内存）缓存挂了。出现的原因是NIO引起的，因为NIO程序经常使用allocateDirect创建字节BUff进行数据缓存，所以不在堆内存中GC管理不到，所以哪些Buffer很肯能没被回收导致本地内存被用光。
        本地内存：JVM以外可用的内存，默认是物理内存容量的1/4；

    5：java.lang.OutOfMemoryError:unable to create new native thread
        在高并发应用中经常出现，该异常与对应的平台有关，原因是应用进程创建了过多的线程超过了系统的承受极限就会报这个错误。
        解决方式：1：降低线程数 2：提升平台的线程承载数

    6：java.lang.OutOfMemoryError:Metaspace
        元空间内存溢出，元空间使用的是本地内存不是在堆中的，里面存放着类模版已经常量池之类的。

3：垃圾回收器：
    四种 GC的回收算法，
            1：引用计数（较难处理循环引用，现在基本不用）
            2：复制算法（在年轻代中使用，在两个s区进行复制清空互换），优点：没有内存碎片 缺点：浪费空间 ，尤其有大对象的时候
            3：标记清除（在老年代中使用，先标记后清除）优点：节约内存空间 缺点：产生了内存碎片
            4：标记整理（在老年代中使用，先标记，后清除，再扫描移动整理确保没内存碎片）优点：节约了内存空间也保证没有内存碎片 缺点：耗费时间比较多
            垃圾收集器是垃圾回收算法的具体落地实现，一般来说Young区用的比较多的算法是复制算法尔Old区用的是标记清楚和标记整理的比较多。

    配置说明：在配置新生代和老年代的GC垃圾回收器的时候，两个区的GC是相互作用的，如果你配了新生代的老年代也会自动被配置好（可互相激活），反之亦然。

    GC参数说明：
        1：DefNew:Default New Generation（默认新生代垃圾回收器,SerialGC）
        2:Tenured:old(老年代,SerialOldGC)
        3:ParNew:Parallel New Generation
        4:PSYoungGen:Parallel Scavenge
        5:ParOldGen:parallel Old generation

        JVM两种模式：
            Server模式:64位操作系统默认的模式
            Client模式:32位操作系统默认是Client模式，内存4G双核以上会切换成Server模式

    1：Serial(串行回收)
        是为单线程环境设计且只能使用一个线程进行垃圾回收，且回收期间会暂停所有用户线程的工作，不适合同于服务器环境。
        对应的垃圾回收算法：复制算法/标记整理

        -------用户线程1------>          (Serial垃圾回收期间)          -------用户线程1------>
        -------用户线程2------>  --------Serial垃圾回收线程------>     -------用户线程2------>
        -------用户线程n------>                                       -------用户线程n------>

        对应的垃圾回收器：
            1:SerialGC (用于新生代的串行回收器,复制算法)
                激活参数：-XX:+UseSerialGC

                这是一种最稳定效率也最高的收集器，但是速度慢，如果使用了串行收集器默认老年代会使用其关联的老年代的SerialOldGC收集器。
            2:SerialOldGC (用于老年代的串行回收器，标记整理,已废弃)

    2：Parallel(并行收集)Java8默认
        多个垃圾回收线程并行工作，期间用户线程暂停，适合用于大数据处理科学技术等弱交互的场景,多线程并行停顿时间短，单如果应用运行环境是单核的并行性能可能比串行更差，因为又线程上下文切换的消耗
        对应的垃圾回收算法：

         -------用户线程1------>          (Parallel垃圾回收期间)          -------用户线程1------>
         -------用户线程2------>  --------Parallel垃圾回收线程------>     -------用户线程2------>
         -------用户线程3------>  --------Parallel垃圾回收线程------>     -------用户线程3------>
         -------用户线程n------>                                         -------用户线程n------>

        对应的垃圾回收器：
            1：ParallelGC (用于新生代的并行回收器,复制算法)
                激活参数：-XX:+UseParallelGC

                是一种吞吐量优先的收集器轻代使用多线程并行回收其关联的老年代垃圾收集器为ParallelOldGC，所以老年代也使用并行收集器，这是Java8默认的垃圾回收组合。
                相比ParNew ParallelGC有一种自适应机制，会在运行期间对垃圾回收的一些参数进行调整。
            2: ParallelOldGC (用于老年代的并行回收器,标记整理)
                激活参数：-XX:+UseParallelOldGC
                用于老年代的并行收集器，也就是ParallelGC的老年代版本
            3: ParNewGC (用于新生代的并行回收器,复制算法)
                激活参数：-XX:+UseParNewGC

                这是一种介于SerialGC和ParallelGC之间的GC收集器，使用的是多线程并行的方式进行垃圾收集，还是会停止用户线程，其关联的老年代GC收集器为SerialOldGC，所以老年代还是串行的。
                但由于SerialOldGC已经不推荐使用，所以ParNewGC也要慎用。

    3：CMS(并发收集)
        用户线程和垃圾回收线程可以同时执行（不一定是并发也有可能是交替执行）不需要停顿用户线程（期间会有短暂的停止），互联网企业用的较多，适合用于对响应时间有要求的场景
        对应的垃圾回收算法：（并发）标记清除

          -------用户线程1------>          (Parallel垃圾回收期间)                                -------用户线程1------>
          -------用户线程2------>                        --CMS垃圾回收线程------>                -------用户线程2------>
          -------用户线程3------>   --CMS垃圾回收线程-->  --------用户线程3------>                -------用户线程3------>
          -------用户线程n------>                        -------用户线程1------>                 -------用户线程n------>

        对应的垃圾回收器：
            1:ConMarkSweepGC (用于老年代的CMS回收器,标记清除)
             激活参数：-XX:+UseConcMarkSweepGC

             并发标记清除垃圾收集器，是一种最短停顿时间为目的的垃圾回收器,大型应用服务器首选，缺点是对CPU压力比较大，还是会产生内存碎片在老年代使用该收集器之后新生代会默认使用ParNewGC，同时会将SerialOldGC作为CMS的后备
             CMS必须在老年代内存用尽之前完成回收否则会触发回收失败，收集器会退化成SerialOldGC进行一次stop the world 的FullGC。
             这个垃圾收集器的垃圾收集流程比较复杂，大概分为一下几步：
                1：初始标记，标记一些需要回收的对象，用户线程会停止（只标记GCRoot能够直接关联的对象）。
                2：并发标记，标记全部对象，和用户线程一起执行（进行GCRoot链路扫描）。
                3：重新标记，修正在并发标记初期因为用户线程变动而不需要回收的对象进行修正，会停止用户线程
                4：并发清除，和用户线程一起执行。

    4：G1
        该回收器的思想是将对区分割成多个块来进行垃圾回收处理的。

        对应的垃圾回收器：
            1:G1GC (老年代和新生代都可以使用，整体的标记整理，局部使用标记复制)
             激活参数：-XX:+UseG1GC
             这是一个面向服务端的垃圾收集器，用在多处理器和大内存的服务器场景吞吐量及响应时间相比之前的回收器会有很大的提高，能够进行GC和应用线程并发执行。
             不会产生很多的内存碎片（原理是将整个堆区划分成多个大小Region，每个Region最大只能是32M,这样就提降低了垃圾收集的碎片化），并且用户可以指定垃圾回收时间。
             使用了G1垃圾收集器之后宏观上不再划分Young，Old区，年轻代和老年代会被G1看成一个完整的Heap，再化整为零进行处理避免了全内存扫描，只需要按照区域扫描。
             分区里的逻辑划分是动态变化的，有可能是年轻代也有可能是养老代。
             最多可分为2048个Region 最大支持64G内存。
             针对新生代：region中会进行暂停用户线程进行复制算法清除。
             如果有个超大对象一个region对象装不下，G1就会只能使用多个Region拼成一个大对象区进行处理

             G1内部划分了四种Region类型：1：伊甸园区 2：幸存区 3：养老区 4：超大对象区
            收集步骤：（思想：小区域收集，形成连续的内存块）
                针对伊甸园区：伊甸园区的Region移到Server区的Region，假如幸存区不够伊甸园和幸存区数据会移动到空的区形成新的幸存区，
                幸存区的数据移动到新的幸存区一部分数据会晋升到养老区。

                搜集步骤：
                   1：初始标记，只标记GCRoot能够直接关联的对象。
                   2：并发标记，进行GCRoot链路扫描。
                   3：重新标记，修正在并发标记初期因为用户线程变动而不需要回收的对象进行修正，会停止用户线程
                   4：筛选回收，和用户线程一起执行。

        G1与CMS对比：
            G1优势：1：不会产生内存碎片 2：可以精确的控制GC停顿的时间



    5：ZGC(JDK10之后的默认回收器比较新先不展开)




