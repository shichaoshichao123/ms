注意：类锁和对象锁是不会互相干扰的

java类的对象头的组成：
    1：Mark word：用于存放类的对象的hashCode，分代年龄（用于GC），锁类型，及锁标志等信息
    2：Class Metadata Address：存放了对象的类型指针，指向对象的元类型（元数据），用于确定该对象的是那种类型的数据

monitor：是所有java对象都自带的一种同步机制
    synchronized的原理就是通过monitor的操作指令实现的。并且是可重入的。

JVM锁优化：
    锁消除：给予逃逸分析
    锁粗化：避免反复加锁和解锁。

synchronized锁的四种状态（会随着锁竞争的情况进行锁升级（膨胀））：

   1：无锁：

   2：偏向锁：
        在很多情况下，锁都会由同一个线程获得，为减少同一线程获取锁的代价而引入的，偏向锁不适合锁竞争比较激烈的场景。
      核心思想：
        如果一个线程获得了锁，那么对应的锁就进入偏向模式，锁对象头的mark word的结构也会转变为偏向锁的结构，当该线程再请求该锁时，就无需再进行任何的同步操作，
        即获取锁的过程自需要检查当前锁对象的Mark Word的锁标记是否为偏向锁以及检查当前线程Id是否等于Mrak Word中的ThreadID即可，从而节省了很多有关锁的操作。

   3：轻量级锁（01）：
        由偏向锁升级而来的，当偏向级锁运行在一个线程的同步代码块时，第二个线程j加入锁竞争的时候这时候偏向锁就会膨胀为轻量级锁。适合线程交替执行同步代码块的情况。
        注意：这里在线程竞争锁的时候会采用自旋的方式
   4:重量级锁（10）：
        重量级锁在竞争锁的时候不会自旋


 Fork/Join框架：
    java7之后提供的并行执行框架，是把大任务分割成若干个小人物并行执行然后合并结果得到大任务 的结果的框架。更好的利用多核心运算能力。
    采用工作窃取算法。某个线程从其它队列里窃取任务来执行。（使用双端队列实现，被窃取的线程在队列头部拿任务，窃取任务的线程永远在队列的尾部拿任务）

