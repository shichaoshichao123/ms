注意：类锁和对象锁是不会互相干扰的

java类的对象头的组成：
    1：Mark word：用于存放类的对象的hashCode，分代年龄（用于GC），锁类型，及锁标志等信息
    2：Class Metadata Address：存放了对象的类型指针，指向对象的元类型（元数据），用于确定该对象的是那种类型的数据

monitor：是所有java对象都自带的一种同步机制
    synchronized的原理就是通过monitor的操作指令实现的。并且是可重入的。

JVM锁优化：
    锁消除：给予逃逸分析
    锁粗化：避免反复加锁和解锁。

synchronized锁的四种状态（会随着锁竞争的情况进行锁升级（膨胀））：

   1：无锁：

   2：偏向锁：
        在很多情况下，锁都会由同一个线程获得，为减少同一线程获取锁的代价而引入的，偏向锁不适合锁竞争比较激烈的场景。
      核心思想：
        如果一个线程获得了锁，那么对应的锁就进入偏向模式，锁对象头的mark word的结构也会转变为偏向锁的结构，当该线程再请求该锁时，就无需再进行任何的同步操作，
        即获取锁的过程自需要检查当前锁对象的Mark Word的锁标记是否为偏向锁以及检查当前线程Id是否等于Mrak Word中的ThreadID即可，从而节省了很多有关锁的操作。

   3：轻量级锁（01）：
        由偏向锁升级而来的，当偏向级锁运行在一个线程的同步代码块时，第二个线程j加入锁竞争的时候这时候偏向锁就会膨胀为轻量级锁。适合线程交替执行同步代码块的情况。
        注意：这里在线程竞争锁的时候会采用自旋的方式
   4:重量级锁（10）：
        重量级锁在竞争锁的时候不会自旋


 Fork/Join框架：
    java7之后提供的并行执行框架，是把大任务分割成若干个小人物并行执行然后合并结果得到大任务 的结果的框架。更好的利用多核心运算能力。
    采用工作窃取算法。某个线程从其它队列里窃取任务来执行。（使用双端队列实现，被窃取的线程在队列头部拿任务，窃取任务的线程永远在队列的尾部拿任务）

tip：synchronized关键字修饰的方式，该关键字是不能被继承的，也就是说子类不能继承父类的同步方法，因为同步关键字不属于方法的声明部分。所以需要自己加上。

逃逸分析：
    发布对象：使一个对象能在当前范围之外的代码所使用。
    对象逸出（逃逸）：一种错误的发布，指的是在对象还没有构建完成的时候，就使它被其它线程可见的现象。
避免并发：
安全发布对象：
    1：不可变对象天然就是安全的。不可变指的是，1：对象创建之后状态就不允许修改，2：对象的所有域都是final类型 3：对象在创建期间没有逸出。
    final： 类：不可被继承，成员方法都会被隐式的指定为final方法。
           变量：如果是基本类型的那变量被初始化之后就不允许被修改，如果是引用类型的变量在初始化之后就不允许再指向其它对象，但是可以操作对象的内容，有可能会出现线程安全问题。
           方法：锁定方法一方继承类修改，提高效率，final方法会被JVM进行内联调用，私有方法会被隐式声明为final类型的。

           java中其它方式初始化不可变对象：java中的Collections包下提供了一系列以unmodifiable为前缀的方法，将可变的对象传进去就得到不可变的对象，如Collection，Map，Set，List等传入，那么这个类就不允许被修改，这时候内容也是不允许修改的。
            当然谷歌的guava也提供了相关的API进行不可变对象的声明

线程封闭（将对象封闭在一个线程里，实现线程安全）：
    1：堆栈封闭，方法中的局部变量，不会被线程共享，所以没有并发。
    2：ThreadLocal 线程封闭，推荐使用
        原理：在ThreadLocal维护了一个Map对象，map的key是对应的线程地址，而值就是要进行封闭的对象。
        实际使用：Jdbc数据库链接的Connection对象就是封闭在线程里，来达到线程安全。

线程不安全的写法及避免：
    注意：在方法内定义局部变量进行操作，由于堆栈封闭的因素，所以是天然线程安全的，如果是全局变量的话就要考虑是否线程安全了。
        比如：将StringBuilder替换成StringBuffer ，SimpleDateFormat 替换成 jodaTime相关格式化工具类 ArrayList 换成CopyOnWriterArrayList 等。。。

   Tip:编程中先检查后执行也是一种多线程不安全的编程方法。
            解决方式是，避免将线程共享数据作为判断依据，或者要保证操作的原子性。

  注意：同步容器不一定线程安全，并发容器才算安全

AQS（JUC的核心基于模版方法，所以使用方式是继承，通过实现方法管理其状态）：
    内部提供了一个基于Node组成的先进先出的队列。
    内部原理：
        1：同步队列，是一个双向链表，其中Head节点用于线程调度
        2：条件队列，是一个单向链表，且不是必须的，只有在程序中使用得到了条件，才会用上，并且可能有多个

    作用：可以实现排他锁和共享锁的模式
    执行流程：AQS内部维护了一个同步队列，当线程尝试获取锁失败之后，将会将该线程等待信息信息包装成一个Node并加入到同步队列中，当node为Head节点的直接后继的时候会循环尝试获取锁，当失败的时候就会阻塞自己，知道被唤醒，
    当持有锁的线程释放锁的时候同时会唤醒队列中国呢的直接后继线程。

Future Task（继承自RunnableFuture简介继承Runnable以及Future接口）:
    解决任务执行完毕之后无法获取执行结果的问题。

Fork/Join 框架：原理：工作窃取方法
    局限性：1：该框架执行的任务不应该执行IO操作
           2：同步机制的局限性，只能使用Fork和Join的同步机制
           3：任务不能抛出检查异常

    核心：两个类：
        ForkJoinPool： 负责管理工作线程以及工作的执行状态和信息
        ForkJoinTask：主要提供任务的工作机制

Spring的线程安全：
    无状态对象在Spring中始终是线程安全的


高并发处理思路：
    1：扩容
    2：缓存：
        1：缓存的命中率 2：缓存的最大元素，最大空间。3：缓存的清空策略
    Memcache内存结构：
        slab ——>page-->chunk
        Memcache把内存分为若干个slab每个slab又分为多个page每个page默认大小为1M，page则有chunk组成。chunk是真正存放数据的地方。不同slab中的chunk可存放的内容大小是不一致的
        且申请内容的单位是page。所以chunk里面总有内存浪费，但省去了管理内存碎片的顺耗费。同时淘汰机制是LRU。
        key最大250个字节，最大item是1M，因为分配单位是1M。高性能来自客户端和服务端的一致性hash寻址。

    缓存常见问题：
        1：缓存一致性问题：
               依赖缓存的过期和更新策略，
        2：缓存并发问题：
                同一时间多个请求同时查询同一个数据，这是解决方式是对数据查询以及缓存重建流程加锁，当查询成功并放置到缓存稻种之后再释放。
        3：缓存穿透问题：
            1：对查询结果为空的对象也进行缓存的方式避免穿透
            2：单独对查询结果可能为空的数据单独缓存进行拦截
        4：缓存雪崩问题：
            设置缓存不同的过期时间来避免缓存批量失效，添加控流熔断措施。

    消息队列：
        kafka：








