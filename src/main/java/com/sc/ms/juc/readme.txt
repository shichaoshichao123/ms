注意：类锁和对象锁是不会互相干扰的

java类的对象头的组成：
    1：Mark word：用于存放类的对象的hashCode，分代年龄（用于GC），锁类型，及锁标志等信息
    2：Class Metadata Address：存放了对象的类型指针，指向对象的元类型（元数据），用于确定该对象的是那种类型的数据

monitor：是所有java对象都自带的一种同步机制
    synchronized的原理就是通过monitor的操作指令实现的。并且是可重入的。

JVM锁优化：
    锁消除：给予逃逸分析
    锁粗化：避免反复加锁和解锁。

synchronized锁的四种状态（会随着锁竞争的情况进行锁升级（膨胀））：

   1：无锁：

   2：偏向锁：
        在很多情况下，锁都会由同一个线程获得，为减少同一线程获取锁的代价而引入的，偏向锁不适合锁竞争比较激烈的场景。
      核心思想：
        如果一个线程获得了锁，那么对应的锁就进入偏向模式，锁对象头的mark word的结构也会转变为偏向锁的结构，当该线程再请求该锁时，就无需再进行任何的同步操作，
        即获取锁的过程自需要检查当前锁对象的Mark Word的锁标记是否为偏向锁以及检查当前线程Id是否等于Mrak Word中的ThreadID即可，从而节省了很多有关锁的操作。

   3：轻量级锁（01）：
        由偏向锁升级而来的，当偏向级锁运行在一个线程的同步代码块时，第二个线程j加入锁竞争的时候这时候偏向锁就会膨胀为轻量级锁。适合线程交替执行同步代码块的情况。
        注意：这里在线程竞争锁的时候会采用自旋的方式
   4:重量级锁（10）：
        重量级锁在竞争锁的时候不会自旋


 Fork/Join框架：
    java7之后提供的并行执行框架，是把大任务分割成若干个小人物并行执行然后合并结果得到大任务 的结果的框架。更好的利用多核心运算能力。
    采用工作窃取算法。某个线程从其它队列里窃取任务来执行。（使用双端队列实现，被窃取的线程在队列头部拿任务，窃取任务的线程永远在队列的尾部拿任务）

tip：synchronized关键字修饰的方式，该关键字是不能被继承的，也就是说子类不能继承父类的同步方法，因为同步关键字不属于方法的声明部分。所以需要自己加上。

逃逸分析：
    发布对象：使一个对象能在当前范围之外的代码所使用。
    对象逸出（逃逸）：一种错误的发布，指的是在对象还没有构建完成的时候，就使它被其它线程可见的现象。
避免并发：
安全发布对象：
    1：不可变对象天然就是安全的。不可变指的是，1：对象创建之后状态就不允许修改，2：对象的所有域都是final类型 3：对象在创建期间没有逸出。
    final： 类：不可被继承，成员方法都会被隐式的指定为final方法。
           变量：如果是基本类型的那变量被初始化之后就不允许被修改，如果是引用类型的变量在初始化之后就不允许再指向其它对象，但是可以操作对象的内容，有可能会出现线程安全问题。
           方法：锁定方法一方继承类修改，提高效率，final方法会被JVM进行内联调用，私有方法会被隐式声明为final类型的。

           java中其它方式初始化不可变对象：java中的Collections包下提供了一系列以unmodifiable为前缀的方法，将可变的对象传进去就得到不可变的对象，如Collection，Map，Set，List等传入，那么这个类就不允许被修改，这时候内容也是不允许修改的。
            当然谷歌的guava也提供了相关的API进行不可变对象的声明

线程封闭（将对象封闭在一个线程里，实现线程安全）：
    1：堆栈封闭，方法中的局部变量，不会被线程共享，所以没有并发。
    2：ThreadLocal 线程封闭，推荐使用
        原理：在ThreadLocal维护了一个Map对象，map的key是对应的线程地址，而值就是要进行封闭的对象。
        实际使用：Jdbc数据库链接的Connection对象就是封闭在线程里，来达到线程安全。

线程不安全的写法及避免：
    注意：在方法内定义局部变量进行操作，由于堆栈封闭的因素，所以是天然线程安全的，如果是全局变量的话就要考虑是否线程安全了。
        比如：将StringBuilder替换成StringBuffer ，SimpleDateFormat 替换成 jodaTime相关格式化工具类 ArrayList 换成CopyOnWriterArrayList 等。。。

   Tip:编程中先检查后执行也是一种多线程不安全的编程方法。
            解决方式是，避免将线程共享数据作为判断依据，或者要保证操作的原子性。

  注意：同步容器不一定线程安全，并发容器才算安全


