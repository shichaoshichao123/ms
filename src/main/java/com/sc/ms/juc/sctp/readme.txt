                        java线程池相关基础

在Java中使用Executor接口来定义线程池的最顶层接口
 * 线程池的底层就是ThreadPoolExecutor
 * Executors 是一个线程池的辅助工具类，用于对线程池的辅助操作
 * <p>
 * 线程池的七大基本参数：
 * 1：corePoolSize：线程池核心线程数量，也就是线程池的最初始化的核心线程数。
 * 2：maximumPoolSize：线程池能容纳最多线程数，也就是线程池满负荷下最大线程数，在核心线程被占满了并且工作队列也满了的情况下或进行线程扩容直到数量到Max。
 * 3：keepAliveTime：线程池中多余的空闲线程（当线程池数量大于核心线程数且有线程空闲时间大于指定时间，这些空闲线程将会被回收直到线程数达到核心线程数就才维持）保持存活的时间。
 * 4：unit：这是呼应上面存活时间的单位。
 * 5：workQueue：提交到线程池的工作队列，该队列是一个阻塞队列（候客区）。
 * 6：threadFactory：线程工厂类用于生产工作线程的，一般用默认的参数就行。
 * 7：handler：线程池满后的拒绝策略用于线程池在最大线程数下运行并且阻塞队列也满了的情况下的处理方式。
 * <p>
 * 线程池底层工作原理：
 * 基于7大参数进行理解（基于银行柜台办理业务去理解）
 * 要注意的是核心数满了之后新进入的任务是放在等待队列中的等待队列满了之后才进行线程扩容到最大线程数
 * <p>
 * 线程池JDK提供的四大拒绝策略：
 * 1：AbortPolicy 直接向外抛出异常，这是默认策略。
 * 2：CallerRunsPolicy 将任务原路会退给原先调用线程,让调用者运行。
 * 3：DiscardOldestPolicy 从等待队列中丢弃等待时间最长的任务，以接纳新任务。
 * 4：DiscardPolicy 直接将新任务抛弃。
 * <p>
 * 如何配置线程池的合理数量，是如何考虑的：
 * 考虑因素数： 1：看业务是CPU密集型，还是IO密集型。如果是CUP密集型配：cup核心数+1 ，
 * 如果是IO密集型两种情况：1：由于不会出现高频的上下午切换 所以可以多设置 一般公式 CPU/（1-0.9）0.9为阻塞系数 2：
 * 2：考虑服务器硬件核心数。

注意：yield（暗示CPU当前线程可以让出cpu执行权，但具体调度要看系统）及sleep并不会影响锁的持有，wait（wait要配合Synchronized关键字使用）会让出cpu并且让出锁
 如何停止一个线程：
  1：调用interrupt() 通知该线程该中断了
    1：如果线程在阻塞状态则会直接抛出中断异常。并且线程将立即推出阻塞状态
    2：如果线程处在运行状态则只会把线程的Interrupt标记置为true，线程会继续正常运行下去不受影响。
    使用方式：判断异常中断标志为或者捕获中断异常进行结束线程的逻辑。