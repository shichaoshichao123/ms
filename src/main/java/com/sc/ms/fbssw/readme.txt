                                         分布式事务
1：分布式框架整体结构：
    从上往下：协议（http/Rmi/dubbo/webService）->序列化，反序列化->TCP/UDP

2:主流技术栈：
    1：X/Open DTP模型：
        AP:程序
        RM:资源管理器，一般为数据库，需要实现XA定义的规范
        TM:事务管理器，负责进行事务管理

    2pc协议（两段提交）：
        阶段一：提交事务请求（投票请求）
        阶段二：执行事务请求（提交事务或者回滚事务 ）

        问题：1：数据一致性问题，出现在第二个阶段提交过程中出现网络异常导致事务协调者发生故障，会导致只有一部分的事务参与者接收到Commit请求。
              2：同步阻塞问题，可能会出现事务参与者由于网络问题一直没收到事务提交请求的确认，导致阻塞问题。

    3pc协议（三段提交）：添加了超时功能。
        canCommit：超时取消
        preCommit：超时取消
        doCommit：超时也提交

    XA/JTA：

  3：互联网主流解决方案：

    很少使用那种强一致性的分布式事务的解决方案，
    更多的是采用柔性事务，TCC及补偿机制来保证最终一致性

    1：避免分布式事务：分布式事务本地化，接口功能全面一些。
    2：最终一致性的解决方案-base（e-Bay提出）理论：
        中间可能会存在一些状态的短暂的不一致。
        如：订单表，账户表流程：
            1：插入订单信息
            2：更新账户表余额
       1：MQ方式：
        伪代码：
            1：订单中心创建订单
                1.1:创建成功：发消息通知账户中心进行扣款
                1.2:发送消息失败抛出异常进行订单事务回滚
                1.3:消息丢失理论不存在，消息中间件都有数据持久化功能
            2：账户中心收到消息进行扣款操作
                2.1:扣款成功，流程结束
                2.1：消息重复发送，通过接口幂等。
                    幂等解决：1：数据库层面通过唯一索引进行排除
                             2：记录消费表来判断消息是否以及被消费过
                             3：通过状态判断，乐观锁（通过updata语句的性能高于select的原理）
                2.2:扣款失败，回滚，发送扣款失败的消息。

       2： 查询模式：
            提供一个查询接口，返回当前操作是否成功的状态。
            衰减查询（查询间隔时间递增）。

        补偿模式：
            如果操作状态未知的情况下
            自动恢复：自动重试调用失败的接口，同时对应的接口要做好幂等。
            自动回滚：如果有失败的就回滚之前操作成功的接口。
            人工干预：程序解决不了的进行人工补偿

        TCC事务(最终一致性的方案)：基于三阶段提交
            try：对业务系统中的资源做预留处理
            confirm（采用重试的方式进行确认）：对事务处理进行提交执行
            cancel:回滚事务
         伪代码：客户账户扣款，商户账户入款的过程
            try:冻结客户账户相应的金额，商户不动
            confirm:扣减客户余额，增加商户余额
            cancel:confirm出现问题之后解冻客户余额，解冻失败进行重试或预警。
         成熟框架：
            byteTcc，tcc-transaction

        3:最大努力通知：进行无限重试同步状态

2PC
阶段一（事务准备阶段，耗时间长）：
    1：TM向所有AP发送是否就可以提交事务的请求，并等待回应。
    2：执行事务，各个AP节点，但不会提交事务，只是相当于执行业务逻辑并初始化 redo和undo日志，如果以上执行成功就返回给TM成功的response否则返回失败的报文，
       也就相当于一个投票过程。
阶段二（事务处理阶段，耗时短）：
    1：执行提交事务：当所有AP都返回成功的时候TM会发一个Commit（事务提交）请求，在提交事务过程的过程中任何一个分布式事务参与者返回失败，就会跳到2流程。
    2：中断提交事务：由于存在有的事务没有提交成功，就要进行中断流程，TM会发送abort请求通知其下的AP进行回滚。
缺点：
    1：仍然会存在数据一致性问题，如：在阶段二的时候当AP刚执行完操作之后和TM都离线的情况下TM这边是感知不到原先离线的参与者是什么样的情况。
    2：同步阻塞，在等待AP响应期间是阻塞的，所以这就可能对应用的吞吐能力就有一定的影响
3PC
    在2PC的基础上进行了改进
阶段一：canCommit：确认所以AP可以进行事务操作。

阶段二：preCommit：确认所有AP都进行相关的事务准备

阶段三：doCommit：进行事务操作