TCP:面向连接的可靠的传输层协议
    支持错误重传，滑动窗口，保证可靠性，有序性，重量级的头部20个字节
    为什么需要三次握手才算建立完整的连接：
        主要是为了通信双方要初始化自己的seq值，也就是双方要知道对方的初始化seq值，用于tcp数据传输序号进行数据拼接。
        如果三次握手没完成（服务器发送了初始seq及ack客户端没有返回ack）服务器会无限重试，Linux默认5次等待时间一共63秒

    为什么需要四次挥手才算断开连接：
        第一次挥手：
            客户端向服务短发送FIN=1+Sqe值开始断开连接，同时客户端进入到FIN_WAIT_1状态
        第二次挥手：
            服务端在接收到客户端发来的报问候回复给客户端ACK=1+服务端的Seq(m)及ack=客户端的Seq+1，服务端进入到CLOSE_WAIT状态
        第三次挥手：
            服务器在完成剩余的数据传输之后向客户端发送ACK=1+FIN=1+服务端最新的Seq（n）+ack=客户端的Seq+1的报文给客户端同时进入LAST_ACK状态
        第四次挥手：
            客服端在收到服务端的FIN=1之后向服务器端回复一个ACK=1+Seq=原先客户端Seq+1+ack=当前服务端Seq+1的报文同时客户端进入到TIME_WAIT状态，服务算接收到报文进入
            CLOSE状态完成四次挥手操作。
    为什么在完成四次挥手之后，CLOSE发起方要等待2MSL的超时设置
        1：保证又足够的时间让被动关闭方收到ACK包，（被动方如果没收到会重发FIN，一来一去刚好2MSL）
        2：避免新旧连接被混淆。

    被动关闭方出现大量的CLOSE_WAIT的原因：
        在对方关闭连接之后，程序没有发现，或者没有及时关闭。
        通过：netstat -n | awk '';来处理

    TCP的RTT与RTO
        RTT:指的是发送一个数据包到接收到对应的ACK报文所用的时间
        RTO:指的是重传时间间隔，这个不是写死的，是基于RTT动态计算的。

    TCP的滑动窗口（发送方和接收方都通过滑动窗口来实现）
        发送窗口，和接收窗口。滑动窗口可以进行动态调整
        TCP使用滑动窗口进行流量控制和乱序重排，滑动窗口中包含了已发送但尚未收到接收方ACK确认的以及尚未发送但具备发送条件的数据
        注意滑动窗口的滑动条件必须是之前的连续数据被发送了，在滑动窗口域值之外的将不能发送
        1：保证TCP的可靠性（建立在确认重传机制）
        2：保证TCP的流控特性

