                                                Redis基础知识

优点：
    数据类型丰富
    数据能持久化
    支持主从
    支持分片（3.0之后）

    10万+的QPS：
        单进程单线程，串行执行多个客户端的请求，避免了上下文切换及锁竞争的开销，数据结构简单。
        单核也能处理高并发。NIO，IO多路复用。redis使用的多路复用函数：epoll以及kqueue且select作为保底方案
        基于React设计模式监听IO事件

    FD:文件描述符：
        一个打开的文件通过一个唯一的文件描述符进行引用，该描述符是打开文件的元数据到文件本身的一个映射。

    redis的操作是原子性的不需要考虑多线程的情况。

数据类型：
    String：
        最基本的数据类型，也是二进制安全的（说明可以保持图片等二进制 数据）

    Hash：
        String类型组成的字典，适合用于存储对象

    List：
        列表，按照String类型的插入顺序排序

    Set：
        String类型组成的无序集合，通过Hash表实现，不允许重复

    ZSet：
        有序集合，通过分数进行排序，元素是唯一的但分数可以相同

海量keys中获取指定的前缀的key：

    不要使用keys，keys是阻塞整个服务器获取所有的keys，使用scan，scan是基于游标的迭代器，以0作为开始和结束。可以精确的控制返回的数量
    会存在获取到重复key的问题。

大量的key同时过期的适合会导致卡顿，解决方式是在设置过期时间的适合添加一些随机值。

实现异步队列：
    通过list来实现，方式有两种：
        1：通过LPOP（没有的额时候进行线程Sleep一段时间重试）
        2：通过BLPOP 在没有数据的时候会阻塞指定的时间，有数据的时候就会返回

     通过Redis提供的Subscribe及publish机制实现消息的发布和监听。
     缺点：这里的消息是无状态的，不能保证消息被准确消费。

Redis持久化方式：

1:RDB:
    快照的形式进行数据全量的备份，是一种二进制文件，通过save命令主动去创建RDB快照会阻塞主线程，bgSave会fork出一个线程进行处理不阻塞主线程
    lastSave命令 可以显示上次执行save操作的时间
    自动触发：1：根据配置文件，2：主节点发送RDB文件给从节点 3：redis执行shutdown时
    底层原理：写时复制，只有真正修改该资源是才去复制一份副本。

2:AOF:
    保持写状态。
    是以保存操作命令的形式进行备份的。
    日志重写解决aof问价重复命令多的问题。
    过程：
        aofrewrite命令触发重写的时候先fork一个线程进行新的操作命令写入一个内存缓存中，同时也写到旧的aof中，当新的aof重写完成之后再将内存缓存中将新的命令写入到新的aof文件中，
        最后用新的aof替换旧的aof。
推荐的持久化方式：

RDB-AOF混合持久化方式
    原理：用RDB做全量备份，AOF做增量备份

Pipline：
       通过该技术可以让客户端批量发送命令给Redis执行，减少了IO次数，提高执行效率。

Sentinel ：
        支持分布式，进行redis的高可用的配置，基于留言协议Gossip

Redis集群：
原理：hash环
    通过一致性hash进行服务器在hash环进行定位，存储元素的时候进行hash计算然后顺时针定位节点

    具有较好的容错性。
    问题：会出现数据倾斜。解决方式：引入虚拟节点的方式，为每台服务器生产多个虚拟节点这样再加上虚拟节点到物理节点的映射，这样数据分布就更加均匀了