                                        JVM相关知识

JVM宏观组成部分：
    1：classLoader：类加载器
    2：Runtime Data Area：运行时数据区，也就是我们常说的堆，栈，方法区等。。也就是JVM内存结构模型
    3：Execution Engine：执行引擎，负责方法的具体执行
    4：Native Interface ：本地接口引擎，也就是jvm在执行具体方法的时候有可能会调用一些C++编写的本地接口。也就是可以实现java调用其它语言的类库实现。

ClassLoader：
    组织：
        BootStrapClassLoader：C++实现,加载java自带的一些核心类，路径是java.*。
        ExtClassLoader：java编写实现，加载一些javax.*下的一些类库，用户可以通过将自定义的类放在该路径下实现加载。
        AppClassLoader：java编写实现的，用于加载ClassPath下的类，就是应用的类路径
        ClassLoader（用户自定义）：java编写实现，用户可以自定义加载流程

    双亲委派机制：
        用于不同的类加载器之间的协同工作。防止多份相同字节码被加载，防止系统类库被自定义类库覆盖。

    类的装载过程：
        1：加载：将类的字节码文件加载到虚拟机，并生成class对象
        2：链接:
            1:校验：校验class对象的合法性
            2:准备：为类变量分贝存储空间，并对类变量进行初始化值
            3：解析：将jvm常量池中的符号引用转化为直接引用（静态绑定）
        3：初始化：进行类变量的赋值，及静态代码块的执行
    类的加载方式：
        1：显式加载：loadClass和class.forName
                    只能通过反射支持参数
                    区别：
                        loadClass：得到的类是只完成了类的加载过程而链接和初始化都没做的类对象。
                        forName：得到的类是完成了初始化即 以上三步的类对象。
                    两者的使用场景：
                        loadClass：用于像SpringIOC的类的懒加载需求，我们只是先将相关的bean加载到jvm中不需要做初始化的工作，这时候使用loadClass是很合适的选择
                        forName：用于加载mysql链接驱动之类需要初始化的类库时候，选择forName和适合。
        2：隐式加载：new
                支持参数

jvm存在两种执行方式 1：解释执行 2：编译执行

    1：解释执行指的是逐句解释执行程序，速度慢
    2：编译执行指的是将整个java代码块编译成机器指令后执行，执行属毒药快于解释执行

   在虚拟机中采用的是混合执行的方式，通过二八原则，也就是最常使用的到方法会进行以方法为单位的编译执行，其它八成不常访问的就没必要提前进行编译
   就还是采用解释执行的方式，这也就是有的java代码方法运行的越久执行速度反而越快的原因。

 jvm的组成部分（逻辑上又分为线程共享和线程私有）
    线程共享:
    1：方法区（MateSpace）
    2：堆
        注意：jdk1.8之后常量池被移动到了堆中了。
    线程私有:虚拟机栈，本地方法栈，程序计数器
 3：Java方法栈
    由栈桢组成，栈帧分为：局部变量区(存放基本类型的局部变量以及引用类型的局部变量的引用地址)，字节码的操作数栈，局部变量区相当于一个数组，除了float，及double类型占两个空间之外其它六种基本类型占一个空间单位，也就是32位系统中位4个字节 64位系统为8个字节
    注意：这里指的是基本类型在栈桢中的情况，在堆中是按照实际类型值域吻合的。
 4：本地方法区（NATIVE）
 5：程序计数器（PC寄存器）

 JVM处理异常：

    在编译生成的字节码中，每个方法都附带一个异常表。异常表中的每一个条目代表一个异常处理器，并且由 from 指针、to 指针、target 指针以及所捕获的异常类型构成。这些指针的值是字节码索引（bytecode index，bci），用以定位字节码。
    当程序触发异常时，Java 虚拟机会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引值在某个异常表条目的监控范围内，Java 虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。如果匹配，Java 虚拟机会将控制流转移至该条目 target 指针指向的字节码。
    如果遍历完所有异常表条目，Java 虚拟机仍未匹配到异常处理器，那么它会弹出当前方法对应的 Java 栈帧，并且在调用者（caller）中重复上述操作。在最坏情况下，Java 虚拟机需要遍历当前线程 Java 栈上所有方法的异常表。


 JVM的反射实现：
    反射有两种实现方式：

    本地方法调用（就是字节码中已经定义好的方法）

    动态生成字节码


    两者有什么区别？

    动态生成字节码（以下简称动态实现），生成字节码的过程很慢（类似于准备工作），但是执行效率高。

    本地方法调用，不用生成字节码，直接调用本地方法。所以准备工作几乎没有，很快。但是执行效率就差很多。


    JVM如何做决定选择哪种实现方式？

    通过反射执行的次数来决定，默认值是15。15次之前直接本地调用，之后动态实现。


    JVM为啥分两种实现方式？

    本地实现的调用流程复杂。而在执行多次的情况下，复杂意味着性能损耗，所以有一种适合多次执行的解决方案，就是动态生成字节码。

