                                    数据库相关知识

数据库设计：
    1：存储模块（物理存储）
    2：程序模块（通过程序管理和映射数据的存储逻辑）
        1：存储管理模块：优化IO及数据处理效率，通过块和页作为处理单位（存储的最小单位）
        2：缓存机制模块：将数据缓存至内存中，减少IO访问，提升访问性能
        3：SQL解析模块：将sql缓存，直接解析优化处理速度，
        4：日志管理模块：操作日志记录，用于数据同步及容灾恢复
        5：权限模块：用于进行相关访问的限制
        6：容灾机制模块：用于处理数据库挂掉之后的相关处理
        7：索引管理模块：用于优化查询速度。
        8：锁模块：用于支持并发操作

索引：
    为什么要使用索引？
    大表中避免全表扫描，快速查询数据。
    数据结构？
    BTree（树的高度矮，减少IO次数，查询效率高 ）
        定义：
            1：根结点至少含有2个子节点，书中的每个节点至多含有M（数据库配置的阶数）阶个节点
            2：非根非叶子节点至少含有（M/2）取上限个子节点
            3：所有叶子节点高度都是相同的
            4：每个节点内的元素要升序排序，该节点关键字的个数要小于该节点指向的子节点个数（详见图片）
    B+Tree定义：
        其它与BTree定义基本相同，不同的地方在于：非叶子节点的子树指针与关键字数量相同，这样可以保证存在更多的数据
        2：非叶子节点只用来保存索引（关键字），数据都保持在叶子节点当中。
        3：所以叶子节点都有病一个指针连接下一个叶子节点，由于本身叶子节点就是有序的所以方便进行范围统计

        优点：磁盘读写代价低，查询稳定（所有关键词查询的长度相同，都是从根结点到叶子节点 ），
            有利于数据库的扫描，因为只要扫描所有叶子节点就行，在范围查询中优点明显。
     Hash索引也可以考虑：
        优点：查询效率更高，
        缺点：由于是通过hash算法进行运算的不能进行范围查询，无法进行数据排序工作，不能利用部分索引进行查询，不能避免表扫描


     BitMap（位图索引）：
        支持的数据库不多（Oracle支持），并且只适合用于属性的值是固定的几个，并且位图索引锁的粒度大，不适合高并发的场景。

 密集（聚集）索引和稀疏（非聚集）索引的区别：
    密集索引：
        密集索引的索引文件中每个搜索码值都对应一个索引值
        一个表只能有一个密集索引（针对InnoDB）生成规则：有主建的情况下主建会被建立密集索引，没有主键则该表的第一个唯一非空索引会被作为密集索引，如果以上都不满足
        那么InnoDB内部会生成一个隐藏的主键（密集索引，六字节的列，自增）。
        在InnoDB中主键索引（密集索引）的叶子节点是保存了主键对应的数据的，其它辅助索引中保存了对应的主键的值，在使用非主键索引查询中先通过辅助索引（稀疏索引）树查找到对应的主键树的地址宰通过主键索引树获取到指定的数据，
        而使用主键索引查找数据的适合只需要通过主键索引树直接进行数据的检索（如图）。
        以上是针对支持密集索引的数据库引擎，如InnoDB的

    稀疏索引：
        稀疏索引只为搜索码值的某些值建立索引项
        er对于只支持稀疏索引的数据库引擎（如：MYISAM）来说，它的主键索引和辅助索引都是一样的，而数据是单独存储的，所以通过主键索引查询和辅助索引查询过程其实是独立的。

    总结：支持密集索引的数据库引擎他的数据和索引是存放在一个文件下的，也就是密集索引下面挂数据，而不支持密集索引的数据库引擎他的索引文件和数据是分开存储的。

    force index 强制走哪个索引

 联合索引最左匹配原则成因：
    最左匹配原则成因（看图）。
    mysql在使用联合索引的时候会强制对联合索引中的排在第一位的索引进行排序，接下来是第二位的排序。所以使用联合索引要符合最左匹配原则

 索引不是越多越好：
    1:数据量小的表不需要索引
    2:索引需要额外维护索引不是越多越好


 数据库中的锁
    sql语句后面使用 forUpdate 就会为该sql语句的执行加上了排他锁。
    sql语句后面使用 lock in share mode 就会为该sql语句的执行加上了共享锁。

 1：MyISAM与InnoDB锁的区别：
    注意：锁的粒度越细代价越高。
    1：MyISAM默认使用的是表级锁，不支持行级锁。
        MyISAM在进行查询的时候会将某张表进行加表级别的读锁（共享锁），增删改的时候就会加上表级别的写锁（排他锁）。
        表级锁和索引无关
        适合场景：频繁全表Count的情况，对表修改少查询多的情况，没有事物的场景
    2：InnoDB默认使用的是行级锁，同时也支持表级锁。
        InnoDB采用的操作是二段提交的方式。
        行级锁与索引有关，也就是说SQL如果操作没使用索引的时候就会使用表级锁（很重要）。
        SQL用到索引的时候使用的是行级锁和间隙锁
        适合场景：数据修改多的场景，可靠性要求高，需要支持事物的场景

 2：数据库事物的四大特性
    A：原子性
    C：一致性
    I：隔离性
    D：持久性

 3：事物的隔离级别，以及各个隔离级别下的并发访问问题
    问题：脏读，不可重复度，幻读
    1：读未提交 会出现：脏读，不可重复度，幻读
    2：读已提交（Oracle默认级别） 解决：脏读 会出现：不可重复度，幻读
    3：可重复度（MySql（InnoDB）默认级别） 解决：脏读，不可重复度， 会出现：幻读（MySQL(InnoDB)在可重复读的情况下避免了幻读）
    4：读序列化 解决：脏读，不可重复度，幻读

 4：MySql的InnoDB在可重复度的隔离级别下如何让解决幻读问题
    实现原理
    表象：快照读（伪MVCC下的非阻塞读，没有实现真正的多版本共存）：
        当前读和快照读：
            当前读是加了锁的增删改查操作。
            快照读是不加锁的非阻塞读（隔离界别不在读序列化的情况下），基于多版本并发控制（MVCC）
    内在：next-key锁（行锁+gap（间隙）锁，这是读序列化的实现原理）：
         gap锁：
         1:如果where条件数据全部命中，这时只会加行锁，不会加gap锁。]
         2:如果结果集没有全部命中或全部没命中，这时候就会被加上gap锁，
         主要用在where走非唯一索引或不走索引的当前读当中，走非唯一索引的情况下gap左开又闭，注意gap锁具体值与主键值排序有关系。
         同时注意不走索引的情况会把所有gap都给锁住比表锁效率更差。


 5：RC（读已提交），RR(可重复度)级别下InnoDB的非阻塞读（快照读）是如何实现的
    原理：根据几个比较重要的属性：DB_TRX_ID（事物ID），DB_ROLL_PTR（回滚指针,undo_log中回滚段指针），DB_ROW_ID(行号)，undo_log(insert,update)，read view

    RC下：
        快照读和当前读读取到的数据是一样的，原因是使用的是同一个read view。
    RR下：
        快照读读取到的是数据的历史版本也有可能读到最新版本（根据创建快照的时机定的，也就是数据修改提交前后创建快照）而当前读返回的数据最新版本，原因是使用的不同的read view。


 语法部分：
    1：GROUP BY:
        1：只能用在select中用到的列或带有SUM之类函数中可以使用其它列，同时只对同一张表成立
    2：ORDER BY:

    统计相关：
    COUNT：
    SUM：
    MAX：
    MIN：
    AVG：

